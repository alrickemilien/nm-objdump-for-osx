#
# Header
#

[HEADER]

# Magic number
# uint32_t
# Possible valid values :
# 0xfeedfacf // MH_MAGIC_64
# 0xcffaedfe // MH_CIGAM_64
magic_number=0xfeedfacf

# cputype number
# uint32_t
cputype=0x5656

# cpusubtype
# uint32_t
cpusubtype=0x12

# Filetype
# uint32_t
# Possible valid values :
#define LC_SEGMENT      0x1     /* segment of this file to be mapped */
#define LC_SYMTAB       0x2     /* link-edit stab symbol table info */
#define LC_SYMSEG       0x3     /* link-edit gdb symbol table info (obsolete) */
#define LC_THREAD       0x4     /* thread */
#define LC_UNIXTHREAD   0x5     /* unix thread (includes a stack) */
#define LC_LOADFVMLIB   0x6     /* load a specified fixed VM shared library */
#define LC_IDFVMLIB     0x7     /* fixed VM shared library identification */
#define LC_IDENT        0x8     /* object identification info (obsolete) */
#define LC_FVMFILE      0x9     /* fixed VM file inclusion (internal use) */
#define LC_PREPAGE      0xa     /* prepage command (internal use) */
#define LC_DYSYMTAB     0xb     /* dynamic link-edit symbol table info */
#define LC_LOAD_DYLIB   0xc     /* load a dynamically linked shared library */
#define LC_ID_DYLIB     0xd     /* dynamically linked shared lib ident */
#define LC_LOAD_DYLINKER 0xe    /* load a dynamic linker */
#define LC_ID_DYLINKER  0xf     /* dynamic linker identification */
#define LC_PREBOUND_DYLIB 0x10  /* modules prebound for a dynamically */
#define LC_ROUTINES     0x11    /* image routines */
#define LC_SUB_FRAMEWORK 0x12   /* sub framework */
#define LC_SUB_UMBRELLA 0x13    /* sub umbrella */
#define LC_SUB_CLIENT   0x14    /* sub client */
#define LC_SUB_LIBRARY  0x15    /* sub library */
#define LC_TWOLEVEL_HINTS 0x16  /* two-level namespace lookup hints */
#define LC_PREBIND_CKSUM  0x17  /* prebind checksum */
filetype=0x1

# number of load commands
# uint32_t
ncmds=0x42

# The size of all the load commands
# uint32_t
sizeofcmds=0xFF

# Magic number
# uint32_t
# Possible valid values :
#define MH_NOUNDEFS     0x1
#define MH_INCRLINK     0x2
#define MH_DYLDLINK     0x4
#define MH_BINDATLOAD   0x8
#define MH_PREBOUND     0x10
#define MH_SPLIT_SEGS   0x20
#define MH_LAZY_INIT    0x40
#define MH_TWOLEVEL     0x80
#define MH_FORCE_FLAT   0x100
#define MH_NOMULTIDEFS  0x200
#define MH_NOFIXPREBINDING 0x400
#define MH_PREBINDABLE  0x800
#define MH_ALLMODSBOUND 0x1000
#define MH_SUBSECTIONS_VIA_SYMBOLS 0x2000
#define MH_CANONICAL    0x4000
#define MH_WEAK_DEFINES 0x8000
#define MH_BINDS_TO_WEAK 0x10000
#define MH_ALLOW_STACK_EXECUTION 0x20000
#define MH_ROOT_SAFE 0x40000
#define MH_SETUID_SAFE 0x80000
#define MH_NO_REEXPORTED_DYLIBS 0x100000
#define MH_PIE 0x200000
#define MH_DEAD_STRIPPABLE_DYLIB 0x400000
#define MH_HAS_TLV_DESCRIPTORS 0x800000
#define MH_NO_HEAP_EXECUTION 0x1000000
#define MH_APP_EXTENSION_SAFE 0x02000000
flags=0x10

# reserved
# uint32_t
reserved=0x8

#
# Load command
#

[LOAD_COMMAND]

cmd=0x88
cmdsize=0x96
section_architecture=0x64

[SECTION_COMMAND]

#
# Section
#
# struct section { /* for 32-bit architectures */
#         char            sectname[16];   /* name of this section */
#         char            segname[16];    /* segment this section goes in */
#         uint32_t        addr;           /* memory address of this section */
#         uint32_t        size;           /* size in bytes of this section */
#         uint32_t        offset;         /* file offset of this section */
#         uint32_t        align;          /* section alignment (power of 2) */
#         uint32_t        reloff;         /* file offset of relocation entries */
#         uint32_t        nreloc;         /* number of relocation entries */
#         uint32_t        flags;          /* flags (section type and attributes)*/
#         uint32_t        reserved1;      /* reserved (for offset or index) */
#         uint32_t        reserved2;      /* reserved (for count or sizeof) */
# };
#
# struct section_64 { /* for 64-bit architectures */
#         char            sectname[16];   /* name of this section */
#         char            segname[16];    /* segment this section goes in */
#         uint64_t        addr;           /* memory address of this section */
#         uint64_t        size;           /* size in bytes of this section */
#         uint32_t        offset;         /* file offset of this section */
#         uint32_t        align;          /* section alignment (power of 2) */
#         uint32_t        reloff;         /* file offset of relocation entries */
#         uint32_t        nreloc;         /* number of relocation entries */
#         uint32_t        flags;          /* flags (section type and attributes)*/
#         uint32_t        reserved1;      /* reserved (for offset or index) */
#         uint32_t        reserved2;      /* reserved (for count or sizeof) */
#         uint32_t        reserved3;      /* reserved */
# };

#
# x64 bits values for strcuture

# name of this section
# It is a 16 bytes length string, you can put enpty or greater 16 bytes to
# trash garbage file
sectname[16] = wefwef

# segment this section goes in
# It is a 16 bytes length string, you can put empty or greater 16 bytes to
# trash garbage file
segname[16]= efwefww

# uint32_t
# memory address of this section
addr = 0x5465464

# uint32_t
# size in bytes of this section
size = 0x5465464

# uint32_t
# file offset of this section
offset = 0x5465464

# uint32_t
# section alignment (power of 2)
align = 0x5465464

# uint32_t
# file offset of relocation entries
reloff = 0x5465464

# uint32_t
# number of relocation entries
nreloc = 0x5465464

# uint32_t
# flags (section type and attributes)
flags = 0x5465464

# uint32_t
# reserved (for offset or index)
reserved1 = 0x5465464

# uint32_t
# reserved (for count or sizeof)
reserved2 = 0x5465464
